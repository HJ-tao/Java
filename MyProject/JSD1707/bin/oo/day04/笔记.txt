1.方法的重写(Override)
	重新写,覆盖.
	1)发生在父子类中，方法名称相同,参数列表相同,方法体不同
	2)重写方法被调用时,看对象的类型   
	Person zs = new Student()
	zs.say();   调用Student的方法
	
2.重写和重载的区别
	1)重写:
		1.1)发生在父子类中,方法名称相同,参数列表相同,方法体不同
		1.2)遵循"运行期绑定",看对象的类型来调用方法;
	2)重载:
		2.1)发生在一个类中,方法名称相同,参数列表不同,方法体不同
		2.2)遵循"编译期绑定",看引用的类型来绑定方法.
	
3.package和import
	1)package:
		1.1)作用:避免类的命名冲突
		1.2)类的名称:包名.类名
		1.3)包名可以有层次结构.同包中的类不能同名
		1.4)建议:包名所有字母都用小写
	2)import:
	同包中的类可以直接访问,不同包中的类不能直接访问,若想访问有如下两种方式:
		2.1)先import声明类再使用-------建议
		2.2)类的全称------------------太繁琐,不建议

4.访问控制修饰符
	1)public:公有的.所有类
	2)private:私有的.本类
	3)protected:受保护的.本类,子类,同包类
	4)默认的:什么也不写.本类,同包类
	类的访问修饰:public,默认的
	类中成员的访问修饰:如上4种都可以

5.内存管理:由JVM管理
	1)堆
	  1.1)存储所有new出来的对象(包含成员变量)
	  1.2)没有任何引用所指向的对象为垃圾,垃圾回收器(GC)不定时到内存中清扫垃圾,但不一定一发现垃圾就立即回收，
	      调用System.gc()建议JVM尽快调度GC来回收垃圾
	  1.3)内存泄漏:不再使用的内存还没有被及时的回收
	  	  建议:不再使用的对象及时将引用设置为null
	  1.4)成员变量的生命周期:
	  		创建对象时存在堆中,对象被回收时一并消失.
	2)栈
	  2.1)存储正在调用中的方法中的所有局部变量(包括参数)
	  2.2)调用方法时,在栈中为该方法分配一块对应的栈帧,栈帧中存储的是所有的局部变量(包括参数),方法调用结束时,
	      栈帧被清除,局部变量一并失效
	  2.3)局部变量的生命周期:
	  		调用方法时存在栈中,方法调用结束时与栈帧一并被清除
	3)方法区
	  3.1)存储的是.class字节码文件(包括方法)
	  3.2)方法只有一份

6.static:
	1)静态变量
	  1.1)由static修饰
	  1.2)属于类的,存储在方法区中,只有一份
	  1.3)常常通过类名点来访问
	  1.4)何时用:所有对象所共享的资源(图片,音频,视频等)
	2)静态方法
	  2.1)由static修饰
	  2.2)属于类的,存储在方法区中,只有一份
	  2.3)常常通过类名点来访问
	  2.4)静态方法没有隐式this传递的,静态方法中不能直接访问实例成员
	  2.5)何时用:方法的操作仅与参数相关而与对象无关
	3)静态块
	  3.1)由static修饰
	  3.2)属于类的,类被加载时自动执行,因为在类中被加载一次,所以静态块也只执行一次
	  3.3)何时用:加载/初始化静态资源(图片,音频,视频等)

实例变量:没有static修饰,属于对象的,存储在堆中,有几个对象就有几份,对象来访问
静态变量:由static修饰,属于类的,存储在方法区中,只有一份,类名点来访问

成员变量:
1)类中,方法外
2)创建对象时存在堆中,对象被回收时一并被回收
3)有默认值

局部变量:
1)方法中
2)调用方法时存在栈中,方法调用结束被清除
3)没有默认值

 "两同两小一大"原则:
 1)两同:
   1.1)方法名称相同
   1.2)参数列表相同
 2)两小:
   2.1)子类方法的返回值类型小于或等于父类的
   2.2)子类抛出的异常小于或等于父类的----------异常之后
 3)一大:
   3.1)子类方法的访问权限大于或等于父类的------访问控制修饰符后

包名建议:域名的反写,项目名称,模块名称,类名

构造器不能被继承，可以被调用 

1)Override_Demo
2)Override_Overload_Demo
3)StaticDemo

